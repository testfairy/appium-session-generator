"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const logger_1 = __importDefault(require("@wdio/logger"));
const saucelabs_1 = __importDefault(require("saucelabs"));
const utils_1 = require("./utils");
const SC_RELAY_DEPCRECATION_WARNING = [
    'The "scRelay" option is depcrecated and will be removed',
    'with the upcoming versions of @wdio/sauce-service. Please',
    'remove the option as tests should work identically without it.'
].join(' ');
const MAX_SC_START_TRIALS = 3;
const log = logger_1.default('@wdio/sauce-service');
class SauceLauncher {
    constructor(_options, _capabilities, _config) {
        this._options = _options;
        this._capabilities = _capabilities;
        this._config = _config;
        this._api = new saucelabs_1.default(this._config);
    }
    async onPrepare(config, capabilities) {
        var _a;
        if (!this._options.sauceConnect) {
            return;
        }
        const sauceConnectTunnelIdentifier = (((_a = this._options.sauceConnectOpts) === null || _a === void 0 ? void 0 : _a.tunnelIdentifier) ||
            `SC-tunnel-${Math.random().toString().slice(2)}`);
        const sauceConnectOpts = {
            noAutodetect: true,
            tunnelIdentifier: sauceConnectTunnelIdentifier,
            ...this._options.sauceConnectOpts
        };
        let endpointConfigurations = {};
        if (this._options.scRelay) {
            log.warn(SC_RELAY_DEPCRECATION_WARNING);
            const scRelayPort = sauceConnectOpts.sePort || 4445;
            sauceConnectOpts.sePort = scRelayPort;
            endpointConfigurations = {
                protocol: 'http',
                hostname: 'localhost',
                port: scRelayPort
            };
        }
        const prepareCapability = utils_1.makeCapabilityFactory(sauceConnectTunnelIdentifier, endpointConfigurations);
        if (Array.isArray(capabilities)) {
            for (const capability of capabilities) {
                prepareCapability(capability);
            }
        }
        else {
            for (const browserName of Object.keys(capabilities)) {
                prepareCapability(capabilities[browserName].capabilities);
            }
        }
        const obs = new perf_hooks_1.PerformanceObserver((list) => {
            const entry = list.getEntries()[0];
            log.info(`Sauce Connect successfully started after ${entry.duration}ms`);
        });
        obs.observe({ entryTypes: ['measure'], buffered: false });
        perf_hooks_1.performance.mark('sauceConnectStart');
        this._sauceConnectProcess = await this.startTunnel(sauceConnectOpts);
        perf_hooks_1.performance.mark('sauceConnectEnd');
        perf_hooks_1.performance.measure('bootTime', 'sauceConnectStart', 'sauceConnectEnd');
    }
    async startTunnel(sauceConnectOpts, retryCount = 0) {
        try {
            const scProcess = await this._api.startSauceConnect(sauceConnectOpts);
            return scProcess;
        }
        catch (err) {
            ++retryCount;
            if (!err.message.includes('ENOENT') ||
                retryCount >= MAX_SC_START_TRIALS) {
                throw err;
            }
            log.debug(`Failed to start Sauce Connect Proxy due to ${err.stack}`);
            log.debug(`Retrying ${retryCount}/${MAX_SC_START_TRIALS}`);
            return this.startTunnel(sauceConnectOpts, retryCount);
        }
    }
    onComplete() {
        if (!this._sauceConnectProcess) {
            return;
        }
        return this._sauceConnectProcess.close();
    }
}
exports.default = SauceLauncher;
